var Instrumentor = require('./Instrumentor')
	, Module = require('module')
	, TreeSummarizer = require('./tree-summarizer')
	, utils = require('./object-utils')
	, path = require('path')
	, Html = require('./cover_reporters/html')
	, mkdirp = require('mkdirp')
	, fs = require('fs');

/**
 * Removes a module from the cache
 */
require.uncache = function (moduleName) {
    // Run over the cache looking for the files
    // loaded by the specified module name
    require.searchCache(moduleName, function (mod) {
        delete require.cache[mod.id];
    });
};

/**
 * Runs over the cache to search for all the cached
 * files
 */
require.searchCache = function (moduleName, callback) {
    // Resolve the module identified by the specified name
    var mod = require.resolve(moduleName);

    // Check if the module has been resolved and found within
    // the cache
    if (mod && ((mod = require.cache[mod]) !== undefined)) {
        // Recursively go over the results
        (function run(mod) {
            // Go over each of the module's children and
            // run over it
            mod.children.forEach(function (child) {
                run(child);
            });

            // Call the specified callback providing the
            // found module
            callback(mod);
        })(mod);
    }
};

/**
 * Handles all the covering of files
 */
var Cover = function Cover(options) {
	// The currecnt require resolver for .js
	var originalRequire = require.extensions['.js'];
	// Cover options
	var coverOptions = options || {
		includes: ["./lib"]
	};

	// Filters
	coverOptions.filters = coverOptions.filters || [
		/_tests.js/
	]

	// Reporter
	var generator = new Html(options);
	// Coverage instrumentor
	var instrumentor = new Instrumentor();

	this.setOptions = function(options) {
		coverOptions = options || {};
	}

	var flushCache = function(dir) {
		fs.readdirSync(dir).forEach(function(file) {
			var stat = fs.statSync(dir + "/" + file);
			if(stat.isDirectory()) {
				flushCache(dir + "/" + file);
			} else {
				for(var name in require.cache) {
					if(name.indexOf(file) != -1 
						&& name.indexOf('node_module') == -1) {
							// delete require.cache[name];
							require.uncache(name)
					}
				}
			}
		});
	}

	var reloadModules = function(dir) {
		fs.readdirSync(dir).forEach(function(file) {
			var stat = fs.statSync(dir + "/" + file);
			if(stat.isDirectory()) {
				reloadModules(dir + "/" + file);
			} else {
				require(process.cwd() + "/" + dir + "/" + file);
			}
		});		
	}

	this.onPreRun = function(runner) {
		// Get all the test files
		var files = runner.files;

		// Flush cache for all the includes we are interested in
		coverOptions.includes.forEach(function(include) {
			flushCache(include);
		});

		// Override with our own
		require.extensions['.js'] = function(module, filename) {
			// Are we going to instrument it
			var instrument = true;
			// Check if we need to instrument the file
			for(var i = 0; i < files.length; i++) {
				// Get the test file
				var testFile = path.basename(files[i]);
				// Don't instrument the file if it's a test file
				if(filename.indexOf(testFile) != -1) {
					instrument = false;
				}
			}

			// Check if it's in a node_module, and don't instrument if it is
			if(filename.indexOf('node_modules/') != -1) {
				instrument = false;
			}

			// If we have filters check if it matches one
			for(var i = 0; i < coverOptions.filters.length; i++) {
				var filter = coverOptions.filters[i];

				if(typeof filter == 'string') {
					if(filename.indexOf(filter) != -1) {
						instrument = false;
						break;
					}
				} else if(filter instanceof RegExp) {
					if(filename.match(filter) != null) {
						instrument = false;
						break;						
					}
				}
			}

			// The file is not on the passed in list, instrument it
			if(instrument) {
				// Otherwise instrument it
				var file = fs.readFileSync(filename).toString();			
				// Instrument the code
				var instrumentedCode = instrumentor.instrumentSync(file, filename);
				// Get the base name
				var baseName = path.basename(filename);
				// Relative path
				var relativePathFile = filename.replace(process.cwd(), "");
				var relativePath = filename.replace(process.cwd(), "").replace("/" + baseName, "");

				// Create the relative Path
				mkdirp.sync("./out/" + relativePath, 0777);
				// Write the instrumented file
				fs.writeFileSync("./out/" + relativePathFile, instrumentedCode);
				// Return the compiled module
				return module._compile(instrumentedCode, filename);
			}

			// Return the original module
			return originalRequire(module, filename);
		}		

		coverOptions.includes.forEach(function(include) {
			reloadModules(include);
		});		
	}

	this.onExit = function() {
		// Create an instance of the Tree Summarizer
		var summarizer = new TreeSummarizer();
		// Undefined __coverage__ ignore
		if(global.__coverage__ == undefined) __coverage__ = {};
		// For each file in coverage, let's generate
		for(var filename in __coverage__) {
			// Get the coverage
			var coverage = __coverage__[filename];
			
			// Add content to summarizer
			summarizer.addFileCoverageSummary(filename, utils.summarizeFileCoverage(coverage));
		}

		// Get the tree summary
		var tree = summarizer.getTreeSummary();
		// Execute generation of html page
		generator.generate(tree.root, __coverage__);
		// Flush Tree to disk as json
		fs.writeFileSync("./out/cover/cover_data_summarized.json", JSON.stringify(tree, null, 2));
		fs.writeFileSync("./out/cover/cover_data_raw.json", JSON.stringify(__coverage__, null, 2));
	}

	this.onTestStart = function() {
	}

	this.onTestEnd = function() {
	}

	this.onTestSuiteStart = function(configurations) {
	}

	this.onTestSuiteEnd = function() {
	}
}

module.exports = Cover;